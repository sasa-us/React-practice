install nodejs 
npm install create-react-app
create project folder 'react-complete-guide'
if create-react-app react-complete-guide --scripts-version 1.1.5 not works
use:
npx create-react-app react-complete-guide --scripts-version 1.1.5

run:
cd react-complete-guide
npm start

it will show on 
  Local:            http://localhost:3000/
  On Your Network:  http://192.168.1.187:3000/

every assignment after copy to folder need go to this folder
cosole: npm install and then npm start run it.


compiles to the end is the result of react.createElement
all staff in render will be check when rerender occur, and then return sth
state change will tigger render
//----
component is class 
need mport React, {Component} from 'react';
use method render (); to render to DOM
class use same name as file name
// jsx
className vs class 
wrap everything in 1 div root element return 

// react all about component
component is just a function, which return jsx (html in js)
es6 use const

JSX & Component
Component is the core building block of React 
Component tree- root component App ->infinity nested child components
Component need return / render JSX (HTML) to DOM
reuseable
JSX is not HTML, just looks like class->className
JSX is suntactic sugar for js, allow you to write HTMLish code instead by use html style (React.createElement)

import component use uppercase of that component

create component
1 functional component
const cmp = () => { return ( <div> JSX HERE </div>);}
return 
should use functional component as ofen as posibale 
because you should use state carefully
have state in all component and manipulate anywhere in app make app unpredictable and hard to manage



2 class component . container / stateful components
class Cmp extends Component {
  render() { return <div> JSX HERE </div>}
}
render
use { } to wrap js func for dynamic use
----------------------------------------------------
props: outside info
pass data from parent wraping component  to a child by < />  
pass valued parameter between different js file and output them
Person=(props)=> { return {props.name}}

use class based component use {this.props}

<component />
<component> </component>
{props.children} could output anything between closing tag component <></>
------------------------------------------------------
state: inside class component info
inside component
special property: state only use by class component (like constructor)
state's change will rerender& update DOM

------------------------------
40 event handler func use arrow func
if not arrow func, 'this' will not refer to this class and reach state property
then button use {this.xx}
no () after this.xx, since don;t execute it immediately, only click
reference: different event handler
https://reactjs.org/docs/events.html#supported-events

41 change state setState( {
  take obj as argument, merge defined exist state/
});

---------------------------------
state in func component by use 
assign a capitalized variable const App = () => { ... }
--------------------------------

react hook React 16.8
istead of state={}
change class component to function component
collection of func 

set state could use multiple seperate  state slice
useState({
  state's staff
}); 
return array with only two element,
 1st element is access state, // instead of state = 
2nd elem is a function allow us to update/replace this state to re render component //instead of setState()  merge, but replace
so need manually add all in setxxState, or use useState again
use js arr destructing [1st, 2nd] pull element out of the right side 
this.state change to 1st element.state


add func to a functinal component, just add const in front of func name
----------------------------------
stateful component (container component):
manage component no matter useState hook or classbased setState
stateless component (dumb/presentational component):
no state in this component
better to use stateless component in application, only use state in a few component. otherwise it hard to reuse and maintain

pass method to props to call a mehtod which change state in another/parent component
pass new data in method
recommend use bind
1: bind(this, new value)
   onClick={switchNameHandler.bind(this, 'aa')
2 onClick={() => switchNameHandler('aa')}

-----------------------
input change

----------------------
style
1 import css to same component js file
2 inline style:  jsx style={ }  restrict with hover ... only for this element

state can used in class componenet and pass to child func component through props
if use this in side method,should use => arrow function to keep this refer to this class
event.target refer to the the element event occur on. value will be the property of that value

two way bind: when refersh browser, input still same as output not empty
input component add value={props.currentName}
parrent compoennt add currrentName={this.state.usename}

style which component, then import this style './ .css' in this component and add this style 
class /id or any css in this component div not app.js


======================== sec 4= =======================================
add new in state
add { } outside dom element, you can use js statement such as if ...
assign if statement as variable in render and return this var 

------------
56 list use .map( (xx, index) => { return })

delete current person
arr & obj are reference type, only holding a pointer, only change the elemenet point to

do not mutate state directly and js obj is reference type
so we should not mutate it directly since we only get a pointer when reach out to person
hence we would mutate the original object to which this pointer points
so we must create a new js obj, then use spread operator... in front of obj i'm fetching
...obj  (same as ...array) ti will distribute all property into new obj created


map doesnot touch original arr. it will give a new arr after return which is store in 
this const xx
str is not js arr so need add split('') below
const charList = this.state.userInput.map( ch => {
      return <Char character={ch} />
    });



    -------------------------sec 5 style
    create obj style can not use sudo selector hover
    only can use for this elem
to style dynamic (two button different color)

    css file

    can not assign value to const obj after define. but can assign new val to this obj its property

    .join(''), will turn arr of string ['', ''] to string  ' '
------------------------------------------------------
    new package radium 
    npm install --save radium
    it allow to use inline style with sudo selectors and media query
    because inline style cannot use sudo selector hover
    higher order component


    -----------
    media query in component with radium
    put style css in component
  1  need wrap export with radium :  export default Radium(person)
    wrap entire app in StyleRoot component (from Radium) in app.js

 2  import Radium, {StyleRoot} from 'radium';
 3 <StyleRoot>
    entire root div
 </StyleRoot>


 ----------
 new library styled component
 styled button
 remove '' and change camalcase to normal 
eg background-color: green,
 use &:hover 
change to ; as css file

-----------dynamic use styled component
alt={}

tweek configuration use "react-scripts": "1.1.5",
npm run eject
(git add . commit ) then npm run eject again
will give you access to the conflict file. so you can tweak how your codes is bundle together
 eject under the hook configuration where you donnot have access to 
underlying web pack conflict file


modules: true,
localIdentName: '[name]__[local]__[hash:base64:5]'

CSS MODULE scope css to certain component 
=======
============ SEC 6 deubug =================================================================
console use source 
take a debug spot then run app. 
step into each step

2 react developer tool --- not recommend from lfz
----------------------
error boundary not tool use everywhere in app.
only use it when you know it might fail and can not control that
its a nice tool for production to show custom err msg and not fail all app
err boundary is higher order component --- has foudler in src
higher order component is a component which wrap component with a goal of handle any err
that compoent throw
be careful the key position should in outer 
componentDidCatch will be exe when component wrap with err boundary throw err
this.prop.children is whatever we wrap inside error boundary -- default case


what in its own component? what group in higher componenent
1 render should be lean and contain not too much jsx.
  so split its big to seperate component
2 if return has a lot of elem tag. it could seperate to its own component
  so only has one div and cockpit comopent and a {xx} working component

src
components
assets has images
containers containers app and its css

-------class based vs func based
class-based 
0 class xy extends Component
1 state
2 lifecycle
3 use this access state&props (this.state.xy   this.props.xy)
4 lifecycle 

func based
0 const xy = (props) => {}
1 use props access props (props.xy)
2 all component only get input, props
if you can and want to use React hooks then use func

89 lifecycle 
only class based
when props change will sync state

render will return jsx (should not send http request / set time out here to block this render process)
after render, it will render child component

componentDidMount called to get http request, get new data from web and finish 
(should not update state call setState here. it will triger rerender cycle )


lifecycle hook rerender ts internal virtual dom and check if the real dom need change
1 call constructor 
2 will call supper
3 call getDerivedStateFromProps
4 render run
5 child component persons render (lifecycle again if it is class component)
6 child person render
7 componentDidMount will run after all component render

91 
update lifecycle (props change)
getDerivedStateFromProps
shouldComponentUpdate(nextProps, nextState)
render()
update child component props
getSnapshotBeforeUpdate()


convert persons & person component to class based to check lifecycle
add render()
props change to this.props  property of this class

persons.js add
getDerivedStateFromProps
shouldComponentUpdate
getSnapshotBeforeUpdate
render() then be called
then componentDidUpdate()


from beginnign to componentDidUpdate in app.js 
will spend a lot time on all child component to finish and then got update
componentDidUpdate fetch data from server
shouldComponentUpdate for performance improvement


useEffect react hook will run for every render cycle
it runs every update, so we can use it for all the things we would have done in componentDidUpdate
eg: http request
IF send request only for 1st time render, not every rerender cycle

94
1 useEffect(()=> {} , [props.persons] )
use [] point all the var or data used in effect here when person changed
2 same as componentDidMount, only want to exe when component render the 1st time
it componentDidMount and componentDidUpdate combine in one effect
useEffect(()=> {} , [] ) use empty arr as no dependency


second important react hook after useState

cleanup event linstener
class component use conponentWillUnmount remove component
function use useEffect and its return clean up
useEffect should have 2nd argument to control when it run
it don't have 2nd argument, it will run every update cycle
use for any action should be cancel when compoennt rerender/update


//persons.js rerender, shouldComponentUpdate
when sth changes
eg: remove cockpit click
if only return true for all. see persons.js shouldComponentUpdate, all persons update hooks ran even through in persons
if add false to it . will only run persons render and others when type sth after remove cockpit

app.js change persons use [...this.state.persons]


//functional component use memo() to optimize re render
use memoization store a snapshot of this component, only if input changes
it will rerender it
if input no change, and parent component want to update this component
react will give it back its stored component
in parent component app.js pass its length

PureComponent = fully checked in shouldComponentUpdate
want to check all props different in a component
since in Persons.js have props.clicked props.changed 
it will return false and not continue


render() won't update real DOM immediately, 
1 compare different old virtual DOM & re render virtual DOM
2 update real DOM if it different
3 it only update the changed part dom

103
error Adjacent jsx element = only 1 div in return outer
1 use [, , ] to wrap all adjacent jsx could be onClick
2 use hoc (higher order component) to wrap other component
Aux.js for auxilliary 

Person.js
use Fragment = Aux for outer in return

hoc
1 WithClass func component
2 a withClass funct return a compoennt const withClass = (a component you want to wrap , className)

108
hoc can be used in many component as wraping folder
<WrappedComponent props={props}/> not work! it pass as single property            
<WrappedComponent {...props}/>

109 setState 
best way use function
(since even setState is called synchronously, but not guaranteed to be excuted and finish immediately
therefore this.state for update in setState is not guaranteed to be latest state or previous state
it could be older state)
so use function and return state
this.setState( (prevState, props) => {
      return {
        persons: persons,
        changeCounter: prevState.changeCounter + 1
      }
      
    });


110 ----------------
  use props correctly type
  npm install --save prop-types
  import PropTypes from 'prop-types';
  add extra property
  lowercase
  .propTypes = {
    //props name
    click: PropTypes.func,    //set as function type use uppercase
}; 

it will get warning when use wrong type
could use most important component, or use build library

--------
focus last input / select elem (.focus() @ old js)
2 use constructorr() { this.inputElRef = React.createRef(); }
  in return ref={this.inputElRef; }

1 class-based component
componentDidMount() {this.inputElementRef.current.focus(); }
in return : ref={(inputEl) => {this.inputEl = inputEl; }}